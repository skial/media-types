package uhx.macro.mime;

import uhx.types.*;
import haxe.macro.Expr;
import haxe.ds.StringMap;
import haxe.macro.Context;
import haxe.macro.Printer;
import haxe.DynamicAccess;

using StringTools;
using sys.io.File;
using haxe.io.Path;
using sys.FileSystem;
using haxe.macro.ExprTools;
using uhx.macro.mime.Helper;
using uhx.macro.mime.TemplateBuilder;

@:enum abstract MimeSource(String) from String to String {
	public var Apache = 'apache';
	public var IANA = 'iana';
	public var NGINX = 'nginx';
}

typedef MimeEntry = {
	@:optional var charset:String;
	@:optional var source:MimeSource;
	@:optional var compressible:Bool;
	@:optional var extensions:Array<String>;
}

class TemplateBuilder {
	
	public static var cwd:String = Sys.getCwd();
	public static var data:String = '$cwd/res/data/';
	public static var resources:String = '$cwd/res/mime-db/';
	public static inline var current:String = '1.25.0';
	public static inline var file:String = 'db.json';
    public static var outputFile:String = '$cwd/src/uhx/types/MimeDb.hx';
	
	private static var printer:Printer = new Printer();
    private static var toplevel:ObjectDecl = new ObjectDecl();
	
	public static macro function build() {
		var path = '$resources$current/$file'.normalize();
		if (!path.exists()) throw '$path does not exist. Please open an issue at https://github.com/skial/media-types/issues/.';
		var json:DynamicAccess<MimeEntry> = haxe.Json.parse( path.getContent() );
		
		//var checker = buildSpellChecker();
		
		var entry = macro class MediaTypeEntry  {
			public var charset:Null<String>;
			public var source:Null<MimeSource>;
			public var compressible:Bool;
			public var extensions:Array<String>;
		}
		entry.meta = [{name:':structInit', params:[], pos: entry.pos}];
		
		var map:StringMap<Expr> = new StringMap();
		var entries = [for (key in json.keys()) {
			var entry = json.get( key );
			var mime = (key:MediaTypeAbstract);
            if (key.startsWith('x')) trace(key, mime);
			var name = mime.haxeify();
			var expr = mime.newMimeStruct();
            mime.store( toplevel );
			map.set( name, expr );
			macro $v{key} => $i{name};
		}];
		
		var fields = [for (key in map.keys()) {
			var expr = map.get( key );
			var field = (macro class Tmp {
				public static var $key:MediaTypeConst = $expr;
			}).fields[0];
			field;
		}];
		
		var db = macro class MimeDb {
			
			public static var db = $e{toplevel.toExpr()};
			//public static var db:Map<String, MediaTypeConst> = [$a{entries}];

		}
        
        fields.sort( alphabeticalFieldSorting );
		db.fields = db.fields.concat( fields );

        outputFile.saveContent( 'package uhx.types;\n\n/* Class autogenerated by `uhx.macro.mime.TemplateBuilder.hx` */\n\n' + printer.printTypeDefinition( db ) );

		return null;
	}

    public static inline function alphabeticalFieldSorting(f1:Field, f2:Field):Int {
        return alphabeticalSorting( f1.name, f2.name );
    }

    public static function alphabeticalSorting(s1:String, s2:String):Int {
		var desc = false;

		if (s1 == s2) return 0;

		s1 = s1.toLowerCase();
		s2 = s2.toLowerCase();

		for (i in 0...s1.length) {
			var n1 : Int = s1.charCodeAt (i);
			var n2 : Int = s2.charCodeAt (i);
			if (n1 < n2)
				return (desc ? 1 : -1); // If descending, the other way around
			else if (n2 < n1)
				return (desc ? -1 : 1);
		}

		return (s1.length < s2.length ? (desc ? 1 : -1) : (desc ? -1 : 1));
	}
	
}
