package uhx.macro.mime;

import uhx.types.*;
import haxe.macro.Expr;
import haxe.ds.StringMap;
import haxe.macro.Context;
import haxe.macro.Printer;
import haxe.DynamicAccess;

using StringTools;
using sys.io.File;
using haxe.io.Path;
using sys.FileSystem;
using haxe.macro.ExprTools;
using uhx.macro.mime.Helper;
using uhx.macro.mime.TemplateBuilder;

class TemplateBuilder {
	
	public static var cwd:String = Sys.getCwd();
	public static var data:String = '$cwd/res/data/';
	public static var resources:String = '$cwd/res/mime-db/';
	public static inline var current:String = '1.25.0';
	public static inline var file:String = 'db.json';
    public static var outputFile:String = '$cwd/src/uhx/types/MimeDb.hx';
	
	private static var printer:Printer = new Printer();
    private static var toplevel:ObjectDecl = new ObjectDecl();
	
	public static macro function build() {
		var path = '$resources$current/$file'.normalize();
		if (!path.exists()) throw '$path does not exist. Please open an issue at https://github.com/skial/media-types/issues/.';
		var json:DynamicAccess<MimeEntry> = haxe.Json.parse( path.getContent() );
		var map:StringMap<Expr> = new StringMap();
		var entries = [for (key in json.keys()) {
			var entry = json.get( key );
			var mime = (key:MediaTypeAbstract);
			var name = mime.haxeify();
			var expr = mime.newMimeStruct( entry );
            mime.store( toplevel );
			map.set( name, expr );
			macro $v{key} => $i{name};
		}];
		
		var fields = [for (key in map.keys()) {
			var expr = map.get( key );
			var field = (macro class Tmp {
				public static var $key:MediaTypeConst = $expr;
			}).fields[0];
			field;
		}];
		
		var db = macro class MimeDb {
			
			//public static var db = $e{toplevel.toExpr()};
			//public static var db:Map<String, MediaTypeConst> = [$a{entries}];

		}
        
        fields.sort( alphabeticalFieldSorting );
		db.fields = db.fields.concat( fields );

        outputFile.saveContent( 'package uhx.types;\n\n/* Class autogenerated by `uhx.macro.mime.TemplateBuilder.hx` */\n\n' + printer.printTypeDefinition( db ) );

		return null;
	}

	public static function modifyStruct(expr:Expr, entry:MimeEntry):Expr {
		switch expr {
			case _.expr => EMeta( { name:':mime' }, _.expr => EParenthesis( _.expr => ECheckType( _.expr => EObjectDecl(fields), type ) ) ):
				var nfields = [];
				nfields.push( { field: 'charset', expr: macro $v{entry.charset} } );
				nfields.push( { field: 'source', expr: entry.source != null ? macro ($v{entry.source}:MimeSource) : macro null } );
				nfields.push( { field: 'compressible', expr: macro $v{entry.compressible} } );
				nfields.push( { field: 'extensions', expr: macro $v{entry.extensions} } );
				
				return macro @:pos(expr.pos) ( $e{{expr:EObjectDecl(fields.concat(nfields)), pos:expr.pos}}:MediaTypeStruct); 

			case _:
				//expr.iter( modifyStruct.bind(_, entry) );

		}

		return expr;
	}

    public static inline function alphabeticalFieldSorting(f1:Field, f2:Field):Int {
        return alphabeticalSorting( f1.name, f2.name );
    }

    public static function alphabeticalSorting(s1:String, s2:String):Int {
		var desc = false;

		if (s1 == s2) return 0;

		s1 = s1.toLowerCase();
		s2 = s2.toLowerCase();

		for (i in 0...s1.length) {
			var n1 : Int = s1.charCodeAt (i);
			var n2 : Int = s2.charCodeAt (i);
			if (n1 < n2)
				return (desc ? 1 : -1); // If descending, the other way around
			else if (n2 < n1)
				return (desc ? -1 : 1);
		}

		return (s1.length < s2.length ? (desc ? 1 : -1) : (desc ? -1 : 1));
	}
	
}
